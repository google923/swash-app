<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#0078d7" />
  <meta name="google-site-verification" content="Tonc5cIN27DjhCRG2R8B9FMVGnGgWn_RFuBKYM2865Q" />
  <title>Swash - Add Customer</title>
  <link rel="manifest" href="../manifest.json" />
  <link rel="icon" href="../assets/favicon-192.png" type="image/png" />
  <link rel="stylesheet" href="../style.css" />
  <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js" defer></script>
  <!-- Ensure Firebase is initialised for this page and expose db/auth on window -->
  <script type="module">
    import { db as fdb, auth as fauth } from "../public/firebase-init.js";
    window.db = fdb;
    window.firebaseAuth = fauth;
  </script>
  <style>
    /* Embed mode: show only the quote form content inside modals/iframes */
    body.embed .header { display: none !important; }
    body.embed .page { padding-top: 0 !important; }
    body.embed { background: transparent; }
    body.embed html, body.embed { overflow: visible !important; }

    /* Responsive modals: fit to device screen */
    #setCustomerLocationModal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.55);
      z-index: 1000;
      padding: 12px;
    }
    #setCustomerLocationModal:not([hidden]) { display: flex; }
    #setCustomerLocationModal .modal__dialog {
      width: min(100vw - 24px, 760px);
      max-height: 90dvh;
      overflow: auto;
      border-radius: 12px;
      padding: 16px;
      background: #fff;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    /* Map height adapts to viewport */
    #locationMap { height: min(60vh, 460px) !important; }

    /* Payment modal inner container responsive sizing */
    #instantPayModal > div {
      width: min(96vw, 520px);
      max-height: 90dvh;
      overflow: auto;
    }

    @media (max-width: 480px) {
      #setCustomerLocationModal .modal__dialog {
        width: 100vw;
        height: 100dvh;
        max-height: 100dvh;
        border-radius: 0;
        padding: 12px;
      }
      #locationMap { height: 60vh !important; }
      #instantPayModal > div {
        width: 100vw;
        height: 100dvh;
        max-height: 100dvh;
        border-radius: 0;
      }
    }
  </style>
</head>
<body class="quote-page">
  <header class="header">
    <div class="header-left">
      <img class="header-logo" src="../assets/swash-logo.png" alt="Swash logo" />
    </div>
    <div class="header-actions">
      <button id="logoutBtn" class="btn btn-secondary" type="button" hidden>Sign out</button>
      <a href="../home.html" id="backToHomeBtn" class="btn btn-secondary">‚Üê Back to Home</a>
      <div class="menu-box">
        <button id="menuBtn" class="btn btn-secondary" aria-haspopup="true" aria-expanded="false">Menu</button>
        <nav id="menuDropdown" class="dropdown">
          <div class="dropdown-title">Rep Resources</div>
          <a id="rep-home-link" class="hidden" href="./rep-home.html">üè† Home</a>
          <a id="add-customer-link" class="hidden" href="./add-new-customer.html">‚ûï Add Customer</a>
          <a href="/rep/rep-log.html">üìù Log</a>
          <a href="./chat.html">üí¨ Rep Chat</a>
          <a href="./policy.html">üìò Policy Handbook</a>
          <a href="./holiday.html">üìÖ Book Holiday</a>
          <a href="./sickness.html">ü§í Report Sickness</a>
          <a href="./commission.html">üí∑ PAY + Commission</a>
          <a href="./map.html">üó∫Ô∏è Territory Map</a>
          <a href="./feedback.html">üí° Feedback / Ideas</a>
          <a href="./performance.html">üéØ Performance Dashboard</a>
          <div class="dropdown-divider"></div>
          <div class="dropdown-title">System</div>
          <a id="login-link" href="./login.html">Sign in</a>
          <a id="quotes-link" class="hidden" href="/pipeline.html">Quotes Dashboard</a>
          <a id="admin-dashboard-link" class="hidden" href="/pipeline.html">Admin Dashboard</a>
          <a id="schedule-link" class="hidden" href="./scheduler.html">Schedule</a>
          <a id="manage-users-link" class="hidden" href="/admin/users.html">Manage Users</a>
        </nav>
      </div>
    </div>
  </header>
  <main class="page">
    <section class="card">
      <header class="card-header">
        <h2>Add Customer</h2>
        <p id="tierDescription">Select a service tier to see the details.</p>
      </header>

      

      <form id="quoteForm" class="form-grid" autocomplete="off">
        <label class="form-section" for="repCode" hidden>
          <span>Rep Code</span>
          <input id="repCode" name="repCode" required value="Website Quote" />
        </label>

        <label class="form-section" for="quoteDate" hidden>
          <span>Quote Date</span>
          <input id="quoteDate" name="quoteDate" readonly />
        </label>

        <div class="options-box">
          <div class="form-grid">
            <label class="form-section" for="serviceTier">
              <span>Service Tier</span>
              <select id="serviceTier" name="serviceTier">
                <option value="gold" selected>Gold</option>
                <option value="silver">Silver</option>
              </select>
            </label>

            <!-- Side-by-side: House Size (left) and House Type (right) -->
            <div class="inline-two">
              <label class="form-section" for="houseSize">
                <span>House Size</span>
                <select id="houseSize" name="houseSize">
                  <option>2 bed</option>
                  <option>3 bed</option>
                  <option>4 bed</option>
                  <option>5 bed</option>
                  <option>6 bed</option>
                </select>
              </label>

              <label class="form-section" for="houseType">
                <span>House Type</span>
                <select id="houseType" name="houseType">
                  <option value="Bungalow">Bungalow</option>
                  <option value="Maisonette">Maisonette</option>
                  <option value="Terrace">Terrace</option>
                  <option value="Semi-Detached">Semi-Detached</option>
                  <option value="Detached">Detached</option>
                  <option value="Mobile Home">Mobile Home</option>
                </select>
              </label>
            </div>

            <!-- Side-by-side larger checkboxes (stay inline on mobile) -->
            <div class="inline-two inline-two--mobile-2">
              <label class="form-section checkbox checkbox--lg" for="conservatory">
                <input type="checkbox" id="conservatory" />
                <span>Conservatory</span>
              </label>

              <label class="form-section checkbox checkbox--lg" for="extension">
                <input type="checkbox" id="extension" />
                <span>Extension</span>
              </label>
            </div>

            <label class="form-section" for="roofLanterns">
              <span>Roof Lanterns</span>
              <div class="slider-row">
                <input type="range" id="roofLanterns" min="0" max="10" value="0" step="1" />
                <span class="slider-value" id="roofLanternsValue">0</span>
              </div>
            </label>

            <label class="form-section" for="skylights">
              <span>Skylights</span>
              <div class="slider-row">
                <input type="range" id="skylights" min="0" max="10" value="0" step="1" />
                <span class="slider-value" id="skylightsValue">0</span>
              </div>
            </label>

            <!-- Alternating moved below price area next to offer button -->

            <input type="hidden" id="partialCleaning" value="100" />
            <input type="hidden" id="addVAT" value="true" />

            <label class="form-section" for="notes">
              <span>Notes</span>
              <textarea id="notes" rows="3" placeholder="Add any customer notes or access information..."></textarea>
            </label>

            <div style="margin-bottom: 16px; padding: 12px; background: #f0f7ff; border-left: 4px solid #0078d7; border-radius: 4px;">
              <label style="display: flex; align-items: center; gap: 8px; font-size: 0.95rem; font-weight: 600; cursor: pointer; color: #1e293b;">
                <input type="checkbox" id="setLocation" style="cursor: pointer; width: 18px; height: 18px;">
                üìç Set Customer Location
              </label>
              <p style="margin: 8px 0 0 26px; color: #64748b; font-size: 0.85rem;">Click the button below to set the exact customer location on a map.</p>
            </div>
            <div style="margin-bottom: 16px;">
              <button type="button" id="setLocationBtn" class="btn btn-secondary" style="width: 100%;">üìç Set Location on Map</button>
            </div>

            <input type="hidden" id="customerLatitude" />
            <input type="hidden" id="customerLongitude" />
          </div>
        </div>

        <!-- Auto-calc enabled: no calculate button needed -->
      </form>

      <!-- Customer details: moved above pricing for better workflow -->
      <section id="customerFields" class="customer-section customer-box" hidden>
        <h3>Customer Details</h3>
        <div class="form-grid">
          <label for="customerName">Full Name</label>
          <input id="customerName" autocomplete="name" required />

          <label for="address">Address</label>
          <input id="address" autocomplete="street-address" required />

          <label for="mobile">Mobile</label>
          <input id="mobile" autocomplete="tel" required />

          <label for="email">Email</label>
          <input id="email" type="email" autocomplete="email" required />
        </div>
      </section>

      <div class="form-actions form-actions--start form-actions--compact" style="margin-bottom: 6px;">
        <label class="checkbox checkbox--lg" for="alternating">
          <input type="checkbox" id="alternating" />
          <span>Alternating Clean</span>
        </label>
        <label class="checkbox checkbox--lg" for="frontOnly">
          <input type="checkbox" id="frontOnly" />
          <span>Front Only</span>
        </label>
        <label class="checkbox checkbox--lg" for="upfrontPayment">
          <input type="checkbox" id="upfrontPayment" />
          <span>Upfront payment (3 cleans)</span>
        </label>
      </div>
      <div class="form-actions form-actions--start" style="width:100%; margin-top: 0; margin-bottom: 8px;">
        <button type="button" id="applyOfferBtn" class="btn btn-offer" style="flex:1;">Apply Special Offer</button>
      </div>
      <section id="result" class="result-panel" aria-live="polite"></section>
      
      <div class="form-grid">
        <label class="form-section" for="emailMessage" hidden>
          <span>Email message</span>
          <textarea id="emailMessage" rows="10" placeholder="This message will be sent to the customer."></textarea>
        </label>
      </div>

      <aside id="paymentRefBox" class="payment-ref" hidden>
        <p><strong>Payment Reference:</strong> <span id="paymentRefValue"></span></p>
      </aside>

      <section id="emailPreviewCard" class="email-preview-card" hidden>
        <div class="email-preview-header">
          <h3>Email Preview</h3>
          <p id="emailPreviewSubject" class="email-preview-subject"></p>
        </div>
        <div id="emailPreviewBody" class="email-preview-body"></div>
      </section>

      <section id="queueAlerts" class="queue-alerts" hidden aria-live="polite"></section>

      <!-- Booking dates display (shown when confirm booking clicked) -->
      <section id="bookingDatesDisplay" class="customer-section" hidden style="background: #ecfdf5; border: 1px solid #10b981; border-radius: 12px; padding: 16px; margin-top: 12px;">
        <h3 style="margin: 0 0 8px; color: #065f46; font-size: 1rem;">üìÖ Booking Dates</h3>
        <div id="bookingDatesContent" style="color: #064e3b; font-size: 0.95rem; line-height: 1.6;"></div>
      </section>

      <!-- Hidden duplicate removed for structural compatibility -->
      <section id="customerFields_old" class="customer-section customer-box" hidden style="display:none;">
        <h3>Customer Details</h3>
        <div class="form-grid">
          <label for="customerName">Full Name</label>
          <input id="customerName" autocomplete="name" required />

          <label for="address">Address</label>
          <input id="address" autocomplete="street-address" required />

          <label for="mobile">Mobile</label>
          <input id="mobile" autocomplete="tel" required />

          <label for="email">Email</label>
          <input id="email" type="email" autocomplete="email" required />
        </div>
      </section>

      <div id="bookingActionBar" class="form-actions form-actions--end" style="flex-direction:column; gap:10px;" hidden>
        <button type="button" id="confirmBookingBtn" class="btn btn-primary" disabled>Confirm Booking</button>
        <button type="button" id="submitBtn" class="btn btn-secondary" hidden>Submit offline booking</button>
      </div>
    </section>
  </main>

  <!-- Embed adapter: enable clean iframe embedding and query prefill -->
  <script>
    (function(){
      try {
        var params = new URLSearchParams(location.search);
        var isEmbed = (function(){ try { return window.self !== window.top; } catch(_) { return true; } })() || params.get('embed') === 'true';
        if (isEmbed) {
          document.body.classList.add('embed-mode');
        }
        // Prefill from query
        var rep = params.get('rep');
        var addr = params.get('address');
        var notes = params.get('notes');
        if (rep) {
          var repEl = document.getElementById('repCode');
          if (repEl) repEl.value = rep;
        }
        if (addr) {
          var addrEl = document.getElementById('address');
          if (addrEl) addrEl.value = addr;
        }
        if (notes) {
          var notesEl = document.getElementById('notes');
          if (notesEl) notesEl.value = notes;
        }
      } catch(_) {}
    })();
  </script>
</body>
</html>
  <div id="setCustomerLocationModal" hidden>
    <div class="modal__dialog">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
        <h3 style="margin: 0;">Set Customer Location</h3>
        <button type="button" class="modal__close" id="closeLocationModal" aria-label="Close">√ó</button>
      </div>
  <p style="color: #64748b; font-size: 0.95rem; margin-bottom: 12px;">Drag the pin to the exact customer location. Address: <strong id="locationAddressDisplay"></strong></p>
  <p id="locationGpsStatus" role="status" style="display: none; margin: -4px 0 12px; font-size: 0.9rem; color: #0369a1;"></p>
      <div id="locationMap" style="width: 100%; height: 400px; border-radius: 8px; border: 2px solid #e5e7eb; margin-bottom: 16px;"></div>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
        <label class="modal__field">
          <span>Latitude</span>
          <input id="locationLatInput" type="number" placeholder="Latitude" step="0.0001" />
        </label>
        <label class="modal__field">
          <span>Longitude</span>
          <input id="locationLngInput" type="number" placeholder="Longitude" step="0.0001" />
        </label>
      </div>
      <div class="modal__actions">
        <button type="button" class="btn btn-secondary" id="cancelLocationBtn">Cancel</button>
        <button type="button" class="btn btn-primary" id="saveLocationBtn">Save Location</button>
      </div>
    </div>
  </div>

  <!-- Google Maps API -->
  <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCcI3UKTFSa-J3t3C3eebXr5tpDFqIznpI&libraries=geometry,drawing&loading=async"></script>
  <!-- QR Code library for Instant Bank Pay (without SRI to avoid blocking if hash changes on CDN) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <!-- Shared navigation (dropdown + rep view + modals) -->
  <script type="module" src="../nav.js"></script>
  <script type="module" src="../rep/script.js"></script>
  
  <!-- Instant Bank Pay Modal -->
  <div id="instantPayModal" hidden style="position: fixed; inset: 0; background: rgba(0,0,0,0.55); align-items: center; justify-content: center; z-index: 1000;">
    <div style="background:#fff; border-radius:12px; padding:20px; width: min(92vw, 480px); box-shadow: 0 10px 30px rgba(0,0,0,0.2);">
      <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
        <h3 style="margin:0; font-size:1.1rem;">Confirm Payment</h3>
        <button type="button" id="instantPayCloseBtn" aria-label="Close" class="btn btn-secondary" style="min-width:auto; padding:6px 10px;">√ó</button>
      </div>
      <p style="margin:0 0 12px; color:#475569;">Scan to confirm your payment securely.</p>
      <div id="instantPayQr" style="display:flex; align-items:center; justify-content:center; padding:12px; border:1px solid #e5e7eb; border-radius:10px; min-height:220px;"></div>
      <p id="instantPayAmountLine" style="text-align:center; margin:12px 0 0; color:#334155; font-weight:600;"></p>
      <div id="instantPayStatus" style="margin-top:12px; text-align:center; color:#64748b; font-size:0.9rem;">Waiting for bank approval‚Ä¶</div>
    </div>
  </div>

  <script>
    // Adds a "Quote Accepted" button next to the price and wires up GoCardless Instant Bank Pay
    (function () {
      // ===== Offline Queue (IndexedDB with localStorage fallback) =====
      const OFFLINE_DB_NAME = 'swash-offline';
      const OFFLINE_STORE = 'paymentLinks';
      const OFFLINE_LS_KEY = 'swashOfflinePaymentLinks';
      function uuid() { return (crypto && crypto.randomUUID) ? crypto.randomUUID() : (Date.now().toString(36) + Math.random().toString(36).slice(2)); }
      function openIdb() {
        return new Promise((resolve, reject) => {
          if (!('indexedDB' in window)) return resolve(null);
          const req = indexedDB.open(OFFLINE_DB_NAME, 1);
          req.onupgradeneeded = () => {
            const db = req.result;
            if (!db.objectStoreNames.contains(OFFLINE_STORE)) db.createObjectStore(OFFLINE_STORE, { keyPath: 'id' });
          };
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => resolve(null);
        });
      }
      async function idbPut(item) {
        const db = await openIdb();
        if (!db) return lsPut(item);
        return new Promise((resolve) => {
          const tx = db.transaction(OFFLINE_STORE, 'readwrite');
          tx.objectStore(OFFLINE_STORE).put(item);
          tx.oncomplete = () => resolve(true);
          tx.onerror = () => { lsPut(item); resolve(false); };
        });
      }
      async function idbGetAll() {
        const db = await openIdb();
        if (!db) return lsGetAll();
        return new Promise((resolve) => {
          const tx = db.transaction(OFFLINE_STORE, 'readonly');
          const req = tx.objectStore(OFFLINE_STORE).getAll();
          req.onsuccess = () => resolve(req.result || []);
          req.onerror = () => resolve(lsGetAll());
        });
      }
      async function idbUpdate(id, partial) {
        const list = await idbGetAll();
        const idx = list.findIndex(x => x.id === id);
        if (idx >= 0) {
          const merged = { ...list[idx], ...partial };
          await idbPut(merged);
          return true;
        }
        return false;
      }
      async function idbRemove(id) {
        const db = await openIdb();
        if (!db) return lsRemove(id);
        return new Promise((resolve) => {
          const tx = db.transaction(OFFLINE_STORE, 'readwrite');
          tx.objectStore(OFFLINE_STORE).delete(id);
          tx.oncomplete = () => resolve(true);
          tx.onerror = () => { lsRemove(id); resolve(false); };
        });
      }
      function lsGetAll() {
        try { return JSON.parse(localStorage.getItem(OFFLINE_LS_KEY) || '[]'); } catch(_) { return []; }
      }
      function lsWrite(arr) { try { localStorage.setItem(OFFLINE_LS_KEY, JSON.stringify(arr || [])); } catch(_) {} }
      function lsPut(item) { const a = lsGetAll(); const idx = a.findIndex(x => x.id === item.id); if (idx>=0) a[idx]=item; else a.push(item); lsWrite(a); }
      function lsRemove(id) { const a = lsGetAll().filter(x => x.id !== id); lsWrite(a); }
      function toPennies(txt) {
        if (!txt) return 0;
        const s = String(txt).replace(/,/g, '');
        // Find the last currency-like number in the string (e.g. takes ¬£79.95 and ignores the preceding "3")
        const re = /¬£?\s*(\d+(?:\.\d{1,2})?)/g;
        let m, last = null;
        while ((m = re.exec(s)) !== null) {
          last = m[1];
        }
        if (!last) return 0;
        const value = parseFloat(last);
        return Number.isFinite(value) ? Math.round(value * 100) : 0;
      }

      function penniesToGBP(p) {
        return '¬£' + (Math.max(0, Number(p || 0)) / 100).toFixed(2);
      }

      function ensureButton() {
        const resultPanel = document.getElementById('result');
        if (!resultPanel) return;
        // place a compact action row under the price box
        let actionRow = document.getElementById('quoteAcceptedRow');
        if (!actionRow) {
          actionRow = document.createElement('div');
          actionRow.id = 'quoteAcceptedRow';
          actionRow.style.display = 'flex';
          actionRow.style.justifyContent = 'flex-end';
          actionRow.style.gap = '8px';
          actionRow.style.marginTop = '8px';
          resultPanel.appendChild(actionRow);
        }
        let btn = document.getElementById('quoteAcceptedBtn');
        if (!btn) {
          btn = document.createElement('button');
          btn.id = 'quoteAcceptedBtn';
          btn.type = 'button';
          btn.className = 'btn btn-primary';
          btn.textContent = 'Take Payment';
          actionRow.appendChild(btn);
          btn.addEventListener('click', handleQuoteAcceptedClick);
          // Payment amount adapts dynamically based on upfront toggle
        }
      }

      function getRepName() {
        try {
          const v = localStorage.getItem('swash:lastRepName');
          return (v && v.trim()) || '';
        } catch (_) { return ''; }
      }

      async function handleQuoteAcceptedClick() {
        try {
          const upfrontToggle = document.getElementById('upfrontPayment');
          if (!upfrontToggle || !upfrontToggle.checked) {
            alert('Enable ‚ÄúUpfront payment (3 cleans)‚Äù to take payment.');
            return;
          }
          // Require pinned customer location before initiating payment
          const latVal = document.getElementById('customerLatitude')?.value;
          const lngVal = document.getElementById('customerLongitude')?.value;
          if (!latVal || !lngVal) {
            alert('Please set the customer location first (Use "Set Location on Map").');
            return;
          }
          // OFFLINE: queue instead of starting GoCardless flow
          if (!navigator.onLine) {
            const form = getCustomerFormData();
            const upfrontToggle = document.getElementById('upfrontPayment');
            const useUpfront = upfrontToggle && upfrontToggle.checked;
            const amountText = useUpfront ? getTextUpfront() : getTextPricePerClean();
            const amount = parseGBP(amountText);
            const repId = (window.userRole && window.userRole.uid) || null;
            const id = uuid();
            const q = {
              id,
              type: 'pending_payment_link',
              offlineSubmitted: true,
              customerName: form.name,
              customerEmail: form.email,
              address: form.address,
              propertyType: form.houseType,
              tierLabel: form.tier,
              totalAmount: amount,
              territoryId: (selectedTerritory && (selectedTerritory.id || selectedTerritory.name)) || null,
              repId,
              timestamp: Date.now(),
              paymentLink: null,
              gocardlessRef: null,
              offlineEmailSent: false,
              retryAt: null,
              retryCount: 0,
            };
            await idbPut(q);
            window.offlineSubmissionActive = true;
            window.offlineEmailSentFlag = false;
            showOfflineAcceptedUi();
            showToast('üì° Offline ‚Äî payment link queued and will be sent when back online.', 'info');
            return; // stop here while offline
          }
          // Determine amount dynamically based on toggle
          const upfrontToggle = document.getElementById('upfrontPayment');
          const useUpfront = upfrontToggle && upfrontToggle.checked;
          let amountPennies = 0;
          let cleanCount = 1;
          
          if (useUpfront) {
            const upfrontNode = document.querySelector('#result .result-upfront');
            if (!upfrontNode) {
            alert('Upfront amount not visible. Toggle ‚ÄúUpfront payment (3 cleans)‚Äù and recalc.');
            return;
          }
          const amountPennies = toPennies(upfrontNode.textContent);
          if (!amountPennies || amountPennies < 100) {
            alert('Invalid amount for payment.');
            return;
          }
          // Build required description: "Payment from (customer name) for 3 window cleans - Rep (rep name)"
          const customerInput = document.getElementById('customerName');
          const customerName = (customerInput && customerInput.value && customerInput.value.trim()) || 'Customer';
          const repName = getRepName() || 'Unknown';
          const cleanText = cleanCount === 1 ? '1 window clean' : '3 window cleans';
          const desc = `Payment from ${customerName} for ${cleanText} - Rep ${repName}`;

          const resp = await fetch('/api/createInstantPayLink', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ amount: amountPennies, currency: 'GBP', description: desc })
          });
          if (!resp.ok) {
            const t = await resp.text();
            throw new Error('Failed to create payment link: ' + t);
          }
          const { redirect_url, session_id } = await resp.json();
          if (!redirect_url || !session_id) {
            throw new Error('Invalid response from payment link service.');
          }

          openInstantPayModal(redirect_url, amountPennies);
          pollPaymentStatus(session_id);
        } catch (err) {
          console.error('Quote Accepted flow failed', err);
          alert('Could not start payment. Please try again in a moment.');
        }
      }

      let pollTimer = null;
      let modalClosed = false;

      function closeInstantPayModal() {
        if (modalClosed) return; // ensure we close only once
        modalClosed = true;
        const modal = document.getElementById('instantPayModal');
        if (modal) {
          modal.style.display = 'none';
          modal.hidden = true;
        }
        if (pollTimer) {
          clearInterval(pollTimer);
          pollTimer = null;
        }
      }

      function openInstantPayModal(url, amountPennies) {
        const modal = document.getElementById('instantPayModal');
        const qrBox = document.getElementById('instantPayQr');
        const amountLine = document.getElementById('instantPayAmountLine');
        const status = document.getElementById('instantPayStatus');
        const closeBtn = document.getElementById('instantPayCloseBtn');
        if (!modal || !qrBox) return;

        // Reset content
        qrBox.innerHTML = '';
  amountLine.textContent = 'Amount: ' + penniesToGBP(amountPennies);
        status.textContent = 'Waiting for bank approval‚Ä¶';
        modalClosed = false;

        // Create QR code pointing to the authorisation URL
        try {
          // global QRCode from qrcodejs
          // eslint-disable-next-line no-undef
          new QRCode(qrBox, {
            text: url,
            width: 220,
            height: 220,
            correctLevel: QRCode.CorrectLevel.M
          });
        } catch (e) {
          // Fallback: show the link clickable
          const a = document.createElement('a');
          a.href = url;
          a.target = '_blank';
          a.rel = 'noopener';
          a.textContent = 'Open payment link';
          a.className = 'btn btn-primary';
          qrBox.appendChild(a);
        }

        modal.hidden = false;
        modal.style.display = 'flex';
        const onBackdrop = (e) => { if (e.target === modal) closeInstantPayModal(); };
        closeBtn.onclick = closeInstantPayModal;
        modal.addEventListener('click', onBackdrop, { once: true });
      }

      async function pollPaymentStatus(sessionId) {
        if (pollTimer) clearInterval(pollTimer);
        const resultPanel = document.getElementById('result');
        const modal = document.getElementById('instantPayModal');
        const status = document.getElementById('instantPayStatus');

        async function checkOnce() {
          try {
            const res = await fetch('/api/checkPaymentStatus?id=' + encodeURIComponent(sessionId));
            if (!res.ok) return; // try again
            const data = await res.json();
            const s = (data && data.status) || 'pending';
            if (s === 'confirmed' || s === 'fulfilled' || s === 'paid') {
              clearInterval(pollTimer);
              pollTimer = null;
              status.textContent = 'Payment confirmed.';
              closeInstantPayModal();
              // Show success banner
              if (!document.getElementById('paymentSuccessBanner')) {
                const banner = document.createElement('div');
                banner.id = 'paymentSuccessBanner';
                banner.textContent = 'üí∏ Payment Received';
                banner.style.background = '#22c55e';
                banner.style.color = '#063b14';
                banner.style.padding = '10px 12px';
                banner.style.borderRadius = '8px';
                banner.style.fontWeight = '700';
                banner.style.marginTop = '10px';
                banner.style.textAlign = 'center';
                resultPanel.appendChild(banner);
              }
              // Present next-step booking actions
              try { renderPostPaymentActions(); } catch(_) {}
            } else if (s === 'cancelled' || s === 'failed' || s === 'denied') {
              clearInterval(pollTimer);
              pollTimer = null;
              status.textContent = 'Payment was not completed.';
            }
          } catch (_) { /* ignore and retry */ }
        }

        // initial and then every 10s
        checkOnce();
        pollTimer = setInterval(checkOnce, 10000);
      }

      // Wait for initial price render, then place the button
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', ensureButton, { once: true });
      } else {
        ensureButton();
      }

      // --- Post-payment booking/email flow ---
  let selectedBooking = null;
  let bookingUiInserted = false;
  let bookedQuotesCache = null; // loaded once for capacity checks
      // Territory detection cache for eligibility gating
      let territoriesCache = null;
      let selectedTerritory = null;
      const BASELINE_START_DATE = '2025-11-03'; // Week 1 baseline (Monday)

      function formatDdMmYyyy(dateOrIso) {
        try {
          const d = (dateOrIso instanceof Date) ? dateOrIso : new Date(dateOrIso);
          const dd = String(d.getDate()).padStart(2,'0');
          const mm = String(d.getMonth()+1).padStart(2,'0');
          const yyyy = d.getFullYear();
          return `${dd}/${mm}/${yyyy}`;
        } catch(_) { return ''; }
      }

      function computeNextDates(firstIso) {
        const first = new Date(firstIso);
        const second = new Date(first);
        second.setDate(first.getDate() + 28);
        const third = new Date(first);
        third.setDate(first.getDate() + 56);
        return { first, second, third };
      }

      function formatDateNice(date) {
        return new Date(date).toLocaleDateString('en-GB', {
          weekday: 'long',
          day: 'numeric',
          month: 'long',
          year: 'numeric'
        });
      }

      function formatDdMmYyyyToday() {
        const d = new Date();
        const dd = String(d.getDate()).padStart(2,'0');
        const mm = String(d.getMonth()+1).padStart(2,'0');
        const yyyy = d.getFullYear();
        return `${dd}/${mm}/${yyyy}`;
      }

      function getTextPricePerClean() {
        const priceNode = document.querySelector('#result .result-price');
        if (!priceNode) return '';
        const m = priceNode.textContent.match(/¬£\s*\d+(?:\.\d{1,2})?/);
        return m ? m[0].replace(/\s+/g,'') : '';
      }

      function getTextUpfront() {
        const n = document.querySelector('#result .result-upfront');
        if (!n) return '';
        const m = n.textContent.match(/¬£\s*\d+(?:\.\d{1,2})?/);
        return m ? m[0].replace(/\s+/g,'') : '';
      }

      function parseGBP(text) {
        if (!text) return 0;
        const s = String(text).replace(/[^0-9.]/g,'');
        const v = parseFloat(s);
        return Number.isFinite(v) ? v : 0;
      }

      function getCustomerFormData() {
        const getCount = (id) => {
          const value = Number(document.getElementById(id)?.value);
          return Number.isFinite(value) ? value : 0;
        };

        const name = document.getElementById('customerName')?.value?.trim() || '';
        const address = document.getElementById('address')?.value?.trim() || '';
        const email = document.getElementById('email')?.value?.trim() || '';
        const mobile = document.getElementById('mobile')?.value?.trim() || '';
        const tier = document.getElementById('serviceTier')?.value || '';
        const houseType = document.getElementById('houseType')?.value || '';
        const houseSize = document.getElementById('houseSize')?.value || '';
        const conservatory = document.getElementById('conservatory')?.checked ?? false;
        const extension = document.getElementById('extension')?.checked ?? false;
        const roofLanterns = getCount('roofLanterns');
        const skylights = getCount('skylights');
        const alternating = document.getElementById('alternating')?.checked ?? false;
        const frontOnly = document.getElementById('frontOnly')?.checked ?? false;
        const notes = document.getElementById('notes')?.value?.trim() || '';
        const pricePerCleanText = getTextPricePerClean();
        const offerAppliedFlag = !!document.querySelector('.result-offer');

        return {
          name,
          address,
          email,
          mobile,
          tier,
          houseType,
          houseSize,
          conservatory,
          extension,
          roofLanterns,
          skylights,
          alternating,
          frontOnly,
          notes,
          offerApplied: offerAppliedFlag,
          pricePerCleanText
        };
      }

      async function saveCustomerBooking(statusKind, bookingPayload) {
        try {
          const db = window.db;
          if (!db) throw new Error('Firestore not initialised');
          const mod = await import('https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js');
          const { collection, addDoc, serverTimestamp, doc, setDoc, getDoc } = mod;

          // Build base
          const base = { createdAt: serverTimestamp(), source: 'add-new-customer', status: statusKind };
          const form = getCustomerFormData();
          const root = {
            name: form.name,
            address: form.address,
            email: form.email,
            mobile: form.mobile,
            tier: form.tier,
            houseType: form.houseType,
            houseSize: form.houseSize,
            pricePerCleanText: form.pricePerCleanText,
            updatedAt: serverTimestamp(),
            source: 'add-new-customer'
          };

          // Ensure customer doc exists or create it
          let customerId = window.swashCustomerId || null;
          if (!customerId) {
            const created = await addDoc(collection(db, 'customers'), root);
            customerId = created?.id || null;
            if (customerId) window.swashCustomerId = customerId;
          } else {
            // Merge basic info if doc exists
            try {
              await setDoc(doc(db, 'customers', customerId), root, { merge: true });
            } catch (_) { /* ignore */ }
          }

          if (!customerId) throw new Error('Could not resolve customerId');

          // Write booking to subcollection customers/{id}/booking
          const booking = { ...base, ...bookingPayload };
          await addDoc(collection(db, 'customers', customerId, 'booking'), booking);
          return customerId;
        } catch (e) {
          console.error('Failed to save booking', e);
          throw e;
        }
      }

      async function sendBookedEmail(params) {
        if (!window.emailjs || !emailjs.send) return false;
        try {
          const EMAIL_SERVICE = 'service_cdy739m';
          const TEMPLATE_ID = 'template_943nfcg';
          await emailjs.send(EMAIL_SERVICE, TEMPLATE_ID, params);
          return true;
        } catch (e) {
          console.warn('Booked email failed', e);
          return false;
        }
      }

      async function sendPendingEmail(params) {
        if (!window.emailjs || !emailjs.send) return false;
        try {
          const EMAIL_SERVICE = 'service_cdy739m';
          const TEMPLATE_ID = 'template_ff5wj9n';
          await emailjs.send(EMAIL_SERVICE, TEMPLATE_ID, params);
          return true;
        } catch (e) {
          console.warn('Pending email failed', e);
          return false;
        }
      }

      function getFirstName(value) {
        const trimmed = (value || '').trim();
        if (!trimmed) return 'there';
        return trimmed.split(/\s+/)[0];
      }

      function getPlanLabel(tier) {
        if (!tier) return 'Silver';
        const normalised = tier.toLowerCase();
        if (normalised === 'gold-for-silver') return 'Gold';
        return normalised.charAt(0).toUpperCase() + normalised.slice(1);
      }

      function formatExtrasList(items = []) {
        if (!items.length) return '';
        if (items.length === 1) return items[0];
        return `${items.slice(0, -1).join(', ')} and ${items[items.length - 1]}`;
      }

      function buildPropertySummary(form) {
        if (!form) return 'home';
        const baseParts = [];
        if (form.houseSize) baseParts.push(form.houseSize.trim());
        if (form.houseType) baseParts.push(form.houseType.trim());
        let summary = baseParts.length ? `${baseParts.join(' ')} home` : 'home';

        const extras = [];
        if (form.conservatory) extras.push('conservatory');
        if (form.extension) extras.push('extension');
        if (form.skylights) {
          const label = form.skylights === 1 ? 'skylight' : 'skylights';
          extras.push(`${form.skylights} ${label}`);
        }
        if (form.roofLanterns) {
          const label = form.roofLanterns === 1 ? 'your roof lantern' : `${form.roofLanterns} roof lanterns`;
          extras.push(label);
        }

        if (extras.length) {
          summary += ` with ${formatExtrasList(extras)}`;
        }
        return summary;
      }

      function composeBookedEmailParams(form, dates) {
        const firstNice = formatDateNice(dates.first);
        const secondNice = formatDateNice(dates.second);
        const thirdNice = formatDateNice(dates.third);
        const firstName = getFirstName(form.name);
        const safeFullName = form.name?.trim() || firstName;
        const planLabel = getPlanLabel(form.tier || 'silver');
        const propertySummary = buildPropertySummary(form);
        const offerSuffix = form.offerApplied ? ' (special offer applied)' : '';
        const priceCopy = form.pricePerCleanText ? form.pricePerCleanText : 'your confirmed rate';
        const repContact = getRepName() ? `If you need anything, just reply to this email or message ${getRepName()}.` : 'If you need anything, just reply to this email.';
        const messageParts = [
          `Hi ${firstName},`,
          `Thank you for choosing Swash Cleaning Ltd. The regular cleaning for your ${propertySummary} is all paid for and scheduled.`,
          `You‚Äôre on our ${planLabel} plan${offerSuffix}, and the price per clean every 4 weeks is ${priceCopy}.`,
          `üóì Your first clean is scheduled for ${firstNice}.`,
          `Your next cleans are expected around:\n‚Ä¢ ${secondNice}\n‚Ä¢ ${thirdNice}\n(Dates may vary slightly due to weather.)`,
          `You‚Äôll receive a reminder email the day before each clean. We look forward to keeping your windows sparkling!`,
          `Please don‚Äôt forget ‚Äî your feedback means the world to us. If you‚Äôre happy, a quick Google review really helps us grow. If there‚Äôs ever an issue, just reply to this email so we can make it right straight away.`,
          `Best regards,\n\nChristopher Wessell\nDirector ‚Äì Swash Cleaning Ltd\nüìû 03300 436 345\nüåê www.swashcleaning.co.uk`,
          repContact
        ].filter(Boolean);
        const message = messageParts.join('\n\n');
        return {
          title: 'Your next 3 window cleans are confirmed!',
          subject: 'Your Swash booking is confirmed',
          customer_name: safeFullName,
          name: safeFullName,
          first_name: firstName,
          email: form.email,
          address: form.address,
          service_address: form.address,
          plan_label: planLabel,
          plan_label_with_offer: `${planLabel}${offerSuffix}`.trim(),
          price_per_clean: form.pricePerCleanText,
          first_date: firstNice,
          first_clean_date: firstNice,
          second_date: secondNice,
          second_clean_date: secondNice,
          third_date: thirdNice,
          third_clean_date: thirdNice,
          second_date_short: formatDdMmYyyy(dates.second),
          third_date_short: formatDdMmYyyy(dates.third),
          rep_name: getRepName() || '',
          offer_applied: form.offerApplied ? 'yes' : 'no',
          house_summary: propertySummary,
          message,
          message_body: message,
          booking_summary: `First clean: ${firstNice} ‚Ä¢ Next cleans: ${secondNice} & ${thirdNice}`
        };
      }

      function composePendingEmailParams(form) {
        const messageParts = [
          `Hi ${getFirstName(form.name)},`,
          `Thanks for your payment ‚Äì you're now on the Swash Cleaning route for ${form.address || 'your property'}.`,
          `We're assigning the next available 4-week slot and will email you with the confirmed date very soon.`,
          form.pricePerCleanText ? `Your plan price is ${form.pricePerCleanText} per clean. We'll keep you on the same cadence going forward.` : '',
          `Need to update anything? Reply to this email or call 03300 436 345.`
        ].filter(Boolean);
        const message = messageParts.join('\n\n');
        return {
          title: 'Payment received ‚Äì we‚Äôre scheduling your first clean',
          subject: 'We‚Äôre lining up your Swash cleaning date',
          customer_name: form.name,
          name: form.name,
          first_name: getFirstName(form.name),
          email: form.email,
          address: form.address,
          price_per_clean: form.pricePerCleanText,
          message,
          message_body: message,
          rep_name: getRepName() || ''
        };
      }

      function showToast(msg, type) {
        const toast = document.createElement('div');
        toast.textContent = msg;
        toast.style.position = 'fixed';
        toast.style.right = '16px';
        toast.style.bottom = '16px';
        toast.style.maxWidth = '90vw';
        toast.style.background = type === 'success' ? '#ecfdf5' : (type === 'warning' ? '#fff7ed' : '#eef2ff');
        toast.style.color = '#0f172a';
        toast.style.border = '1px solid #e2e8f0';
        toast.style.padding = '10px 14px';
        toast.style.borderRadius = '10px';
        toast.style.boxShadow = '0 10px 20px rgba(0,0,0,0.12)';
        toast.style.zIndex = '2000';
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 4200);
      }

      // User-friendly Firestore error helper
      function formatFirestoreError(err) {
        const code = err && (err.code || err.name) || '';
        const message = err && err.message || '';
        let hint = '';
        const text = (code + ' ' + message).toLowerCase();
        if (text.includes('permission')) hint = 'Permission denied ‚Äî check your sign-in and access level.';
        else if (text.includes('unavailable') || text.includes('network')) hint = 'Network/service unavailable ‚Äî check your connection and try again.';
        else if (text.includes('deadline') || text.includes('timeout')) hint = 'Request timed out ‚Äî please try again.';
        else if (text.includes('failed-precondition')) hint = 'Local cache issue ‚Äî try a hard refresh (Ctrl+Shift+R).';
        return { code, message, hint };
      }
      function alertFirestoreError(prefix, err) {
        const { code, message, hint } = formatFirestoreError(err);
        let details = '';
        if (code) details += `\n\nError: ${code}`;
        if (message) details += `\n${message}`;
        if (hint) details += `\nHint: ${hint}`;
        alert(`${prefix}${details}`);
      }

      function updateConfirmBtnState(btn) {
        if (!btn) return;
        const enabled = !!(selectedBooking && selectedBooking.dateISO);
        btn.disabled = !enabled;
        if (enabled) {
          try {
            const d = new Date(selectedBooking.dateISO);
            const nice = d.toLocaleDateString('en-GB', { weekday:'long', day:'numeric', month:'long', year:'numeric' });
            btn.textContent = `Confirm booking for ${nice}`;
          } catch(_) {
            btn.textContent = 'Confirm Booking';
          }
        } else {
          btn.textContent = 'Confirm Booking';
        }
      }

      async function loadBookedQuotesIfNeeded() {
        if (bookedQuotesCache) return bookedQuotesCache;
        try {
          const db = window.db; if (!db) return [];
          const mod = await import('https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js');
          const { collection, query, where, getDocs } = mod;
          const q = query(collection(db, 'quotes'), where('bookedDate', '!=', null));
          const snap = await getDocs(q);
          bookedQuotesCache = snap.docs
            .map(d => ({ id: d.id, ...d.data() }))
            .filter(q => !q.deleted && q.bookedDate);
          return bookedQuotesCache;
        } catch (e) {
          console.warn('loadBookedQuotesIfNeeded failed', e);
          bookedQuotesCache = [];
          return bookedQuotesCache;
        }
      }

      function normalizeYmd(date) {
        const d = new Date(date); d.setHours(0,0,0,0); return d;
      }

      function daysBetween(a, b) {
        const ms = normalizeYmd(b) - normalizeYmd(a); return Math.round(ms / 86400000);
      }

      function occursOnDate(quote, targetDate) {
        try {
          const start = new Date(quote.bookedDate); start.setHours(0,0,0,0);
          const tgt = normalizeYmd(targetDate);
          const diff = daysBetween(start, tgt);
          return diff >= 0 && diff % 28 === 0;
        } catch(_) { return false; }
      }

      function resolvePricePerCleanLocal(quote) {
        const candidates = [quote.pricePerClean, quote.price_per_clean, quote.price];
        for (const v of candidates) { const n = Number(v); if (Number.isFinite(n)) return n; }
        return 0;
      }

      async function computeDayTotalGBP(dateISO) {
        const list = await loadBookedQuotesIfNeeded();
        let sum = 0;
        for (const q of list) {
          if (occursOnDate(q, dateISO)) sum += resolvePricePerCleanLocal(q);
        }
        return sum;
      }

      // ===== Territory detection and date eligibility =====
      function pointInPolygon(point, polygon) {
        if (!point || !Array.isArray(polygon) || polygon.length < 3) return false;
        const x = Number(point.lat), y = Number(point.lng);
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
          const xi = Number(polygon[i].lat), yi = Number(polygon[i].lng);
          const xj = Number(polygon[j].lat), yj = Number(polygon[j].lng);
          const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * (y - yi)) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      function haversineMeters(a, b) {
        const R = 6371000; // meters
        const dLat = (b.lat - a.lat) * Math.PI / 180;
        const dLng = (b.lng - a.lng) * Math.PI / 180;
        const lat1 = a.lat * Math.PI / 180;
        const lat2 = b.lat * Math.PI / 180;
        const s1 = Math.sin(dLat/2), s2 = Math.sin(dLng/2);
        const c = s1*s1 + Math.cos(lat1) * Math.cos(lat2) * s2*s2;
        return 2 * R * Math.asin(Math.min(1, Math.sqrt(c)));
      }

      function pointInCircle(point, center, radiusMeters) {
        if (!point || !center || !Number.isFinite(Number(radiusMeters))) return false;
        return haversineMeters({ lat: Number(point.lat), lng: Number(point.lng) }, { lat: Number(center.lat), lng: Number(center.lng) }) <= Number(radiusMeters);
      }

      async function loadTerritories() {
        if (territoriesCache) return territoriesCache;
        try {
          const db = window.db; if (!db) return [];
          const { getDocs, collection, getDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js');
          // Preferred: top-level territories collection
          const snap = await getDocs(collection(db, 'territories'));
          const arr = [];
          snap.forEach(d => {
            const data = d.data() || {};
            if (Array.isArray(data.geoBoundary)) {
              const path = data.geoBoundary.map(p => ({ lat: p[0], lng: p[1] }));
              arr.push({ id: d.id, name: data.name || d.id, type: 'polygon', path, allowedBookingDays: data.allowedBookingDays || {}, color: data.color || '#0078d7' });
            } else if (data.center && typeof data.radius === 'number') {
              arr.push({ id: d.id, name: data.name || d.id, type: 'circle', center: data.center, radius: data.radius, allowedBookingDays: data.allowedBookingDays || {}, color: data.color || '#0078d7' });
            }
          });
          if (arr.length) { territoriesCache = arr; return territoriesCache; }
          // Fallback: system/territories aggregated doc
          const sys = await getDoc(doc(db, 'system', 'territories'));
          if (sys.exists() && Array.isArray(sys.data().data)) {
            territoriesCache = sys.data().data.map(t => ({
              id: t.id || t.territoryId || t.name,
              name: t.name || t.title || (t.id || 'Area'),
              type: t.type || (t.center && t.radius ? 'circle' : 'polygon'),
              path: Array.isArray(t.path) ? t.path : Array.isArray(t.geoBoundary) ? t.geoBoundary.map(p => ({ lat: p[0], lng: p[1] })) : [],
              center: t.center || null,
              radius: t.radius || null,
              allowedBookingDays: (t.allowedBookingDays && typeof t.allowedBookingDays === 'object') ? t.allowedBookingDays : {},
              color: t.color || t.colour || '#0078d7'
            }));
            return territoriesCache;
          }
        } catch (e) {
          console.warn('loadTerritories failed', e);
        }
        territoriesCache = [];
        return territoriesCache;
      }

      async function detectCustomerTerritory() {
        try {
          const lat = parseFloat(document.getElementById('customerLatitude')?.value);
          const lng = parseFloat(document.getElementById('customerLongitude')?.value);
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) return null;
          const terrs = await loadTerritories();
          const pt = { lat, lng };
          for (const t of terrs) {
            if (t.type === 'polygon' && Array.isArray(t.path) && t.path.length >= 3) {
              if (pointInPolygon(pt, t.path)) return t;
            } else if (t.type === 'circle' && t.center && t.radius != null) {
              if (pointInCircle(pt, t.center, t.radius)) return t;
            }
          }
          return null;
        } catch (_) { return null; }
      }

      function getCycleWeekNumber(date) {
        try {
          const baseline = new Date(BASELINE_START_DATE + 'T00:00:00');
          const weekStart = new Date(date);
          // normalize to Monday
          const day = weekStart.getDay();
          const offset = day === 0 ? -6 : 1 - day;
          weekStart.setDate(weekStart.getDate() + offset);
          const diffWeeks = Math.floor((weekStart - baseline) / (7 * 24 * 60 * 60 * 1000));
          const mod = ((diffWeeks % 4) + 4) % 4;
          return mod + 1;
        } catch(_) { return 1; }
      }

      function getWeekKeyForDate(date) {
        const n = getCycleWeekNumber(date);
        return 'week' + String(n);
      }

      function getDayKeyForDate(date) {
        try {
          const s = new Date(date).toLocaleDateString('en-GB', { weekday: 'short' });
          return s.replace('.', '');
        } catch(_) { return 'Mon'; }
      }

      function renderPostPaymentActions() {
        if (bookingUiInserted) return;
        const resultPanel = document.getElementById('result');
        if (!resultPanel) return;
        const wrap = document.createElement('div');
        wrap.id = 'postPaymentActions';
        wrap.style.marginTop = '10px';
        wrap.style.padding = '12px';
        wrap.style.border = '1px solid #e5e7eb';
        wrap.style.borderRadius = '8px';
        wrap.style.background = '#f8fafc';
        wrap.innerHTML = `
          <div style="display:flex; flex-direction:column; gap:10px;">
            <div id="dummySlots" style="display:none; gap:8px; flex-wrap:wrap; margin-top:8px;"></div>
          </div>
        `;
        resultPanel.appendChild(wrap);
        bookingUiInserted = true;

        const actionBar = document.getElementById('bookingActionBar');
        if (actionBar) actionBar.hidden = false;
        const confirmBtn = document.getElementById('confirmBookingBtn');
        const pendingBtn = document.getElementById('savePendingBtn');
  const capacityInfo = document.createElement('div');
  capacityInfo.id = 'capacityInfo';
  capacityInfo.style.fontSize = '0.9rem';
  capacityInfo.style.color = '#475569';
  capacityInfo.style.marginTop = '6px';
  wrap.appendChild(capacityInfo);
        updateConfirmBtnState(confirmBtn);

        // If no external slot UI is present, do not fabricate dates.
        // Show an informational note only; reps can choose the pending option.
        try {
          if (!window.swashHasSlotUi) {
            const container = document.getElementById('dummySlots');
            // We'll repurpose this container for suggested dates if territory + price known
            container.style.display = 'flex';
            container.id = 'suggestedDatesContainer';
            const heading = document.createElement('div');
            heading.style.flexBasis = '100%';
            heading.style.fontWeight = '600';
            heading.style.fontSize = '0.85rem';
            heading.style.color = '#0f172a';
            heading.textContent = 'Suggested upcoming eligible days';
            container.appendChild(heading);
            const note = document.createElement('div');
            note.style.flexBasis = '100%';
            note.style.fontSize = '0.72rem';
            note.style.color = '#64748b';
            note.textContent = 'Auto-filtered by area, cycle week/day & capacity (< ¬£400). Skips today.';
            container.appendChild(note);
            // Defer generation slightly to allow territory detection
            setTimeout(() => { try { generateSuggestedDates(); } catch(e){ console.warn('generateSuggestedDates failed', e); } }, 400);
          }
        } catch(_) {}

        // Move the pending note below the suggested dates
        const contactNote = document.createElement('div');
        contactNote.id = 'pendingContactNote';
        contactNote.style.fontSize = '0.9rem';
        contactNote.style.color = '#475569';
        contactNote.style.marginTop = '8px';
        contactNote.textContent = "Want us to pick the next slot? Tap the button above and we‚Äôll contact you with a date.";
        wrap.querySelector('#suggestedDatesContainer')?.appendChild(contactNote);

        // Insert an eligibility line below capacity info
        const elig = document.createElement('div');
        elig.id = 'eligibilityInfo';
        elig.style.fontSize = '0.9rem';
        elig.style.color = '#334155';
        elig.style.marginTop = '4px';
        wrap.appendChild(elig);

        confirmBtn?.addEventListener('click', async () => {
          try {
            if (window.offlineSubmissionActive && !window.offlineEmailSentFlag) {
              showToast('Offline payment link not yet sent ‚Äî booking email suppressed.', 'warning');
              return;
            }
            // Require authentication to save booking records
            try {
              const { getAuth } = await import('https://www.gstatic.com/firebasejs/10.8.1/firebase-auth.js');
              const auth = getAuth();
              if (!auth.currentUser) {
                const overlay = document.getElementById('authOverlay');
                if (overlay) { overlay.hidden = false; overlay.style.display = 'flex'; }
                alert('Please sign in to confirm the booking.');
                return;
              }
            } catch(e) { /* proceed; rules may block if unauth */ }
            if (!selectedBooking || !selectedBooking.dateISO) {
              alert('Please select a booking slot first.');
              return;
            }
            const { first, second, third } = computeNextDates(selectedBooking.dateISO);
            const form = getCustomerFormData();

            // Persist booking
            await saveCustomerBooking('booked', {
              firstDateISO: first.toISOString(),
              secondDateISO: second.toISOString(),
              thirdDateISO: third.toISOString(),
              weekKey: selectedBooking.weekKey || null,
              dayKey: selectedBooking.dayKey || null,
              territoryId: selectedBooking.territoryId || null,
              cleanerId: selectedBooking.cleanerId || null,
            });

            // Update existing quote document (status, bookedDate, nextCleanDates, assignedCleaner)
            try {
              const refCode = document.getElementById('paymentRefValue')?.textContent?.trim();
              if (refCode) {
                await updateQuoteDocAfterBooking(refCode, {
                  first,
                  second,
                  third,
                  cleanerId: selectedBooking.cleanerId || null
                });
              }
            } catch (e) { console.warn('Quote doc update (booked) failed', e); }

            // Send confirmation email
            const emailParams = composeBookedEmailParams(form, { first, second, third });
            const sent = await sendBookedEmail(emailParams);
            showToast('‚úÖ Booking confirmed and customer notified.', sent ? 'success' : 'warning');
            try { showThankYouOverlay(form.name, formatDateNice(first)); } catch(_) {}
          } catch (e) {
            console.error('Confirm booking failed', e);
            alertFirestoreError('We saved the payment, but booking could not be completed right now.', e);
          }
        });

        pendingBtn?.addEventListener('click', async () => {
          try {
            if (window.offlineSubmissionActive && !window.offlineEmailSentFlag) {
              showToast('Offline payment link not yet sent ‚Äî pending email suppressed.', 'warning');
              return;
            }
            // Require authentication to save pending booking
            try {
              const { getAuth } = await import('https://www.gstatic.com/firebasejs/10.8.1/firebase-auth.js');
              const auth = getAuth();
              if (!auth.currentUser) {
                const overlay = document.getElementById('authOverlay');
                if (overlay) { overlay.hidden = false; overlay.style.display = 'flex'; }
                alert('Please sign in to save the pending booking.');
                return;
              }
            } catch(e) { /* proceed; will fail if rules require auth */ }
            const form = getCustomerFormData();
            await saveCustomerBooking('pending', {
              territoryId: selectedBooking?.territoryId || null,
            });
            // Update quote doc status to Paid - Scheduling Soon
            try {
              const refCode = document.getElementById('paymentRefValue')?.textContent?.trim();
              if (refCode) {
                await updateQuoteDocPending(refCode);
              }
            } catch (e) { console.warn('Quote doc update (pending) failed', e); }
            const emailParams = composePendingEmailParams(form);
            const sent = await sendPendingEmail(emailParams);
            showToast('üì® Payment received ‚Äî scheduling email sent.', sent ? 'success' : 'warning');
          } catch (e) {
            console.error('Save pending failed', e);
            alertFirestoreError('We could not save the pending booking right now.', e);
          }
        });
      }

      // Allow other UI to set the selected booking slot
      window.setSelectedBooking = function setSelectedBooking(slot) {
        (async () => {
          try {
            selectedBooking = slot && typeof slot === 'object' ? { ...slot } : null;
            const confirmBtn = document.getElementById('confirmBookingBtn');
            updateConfirmBtnState(confirmBtn);
            const info = document.getElementById('capacityInfo');
            if (!selectedBooking || !selectedBooking.dateISO) {
              if (info) info.textContent = '';
              return;
            }
            // Enforce at least +1 day (skip same-day bookings)
            const today = new Date(); today.setHours(0,0,0,0);
            const chosen = new Date(selectedBooking.dateISO); chosen.setHours(0,0,0,0);
            const isSameDay = chosen.getTime() === today.getTime();
            // Resolve territory on-demand
            if (!selectedTerritory) {
              selectedTerritory = await detectCustomerTerritory();
            }

            const baseTotal = await computeDayTotalGBP(selectedBooking.dateISO);
            const priceNode = document.querySelector('#result .result-price');
            let jobPrice = 0;
            if (priceNode) {
              const m = priceNode.textContent.match(/¬£\s*(\d+(?:\.\d{1,2})?)/);
              if (m) jobPrice = parseFloat(m[1] || '0');
            }
            const withThis = baseTotal + jobPrice;
            const limit = 400;
            if (info) info.textContent = `Day total: ¬£${baseTotal.toFixed(2)} ‚Ä¢ With this job: ¬£${withThis.toFixed(2)} (limit ¬£${limit.toFixed(0)})`;
            let over = withThis > limit;

            // Eligibility check against territory allowedBookingDays
            const eligEl = document.getElementById('eligibilityInfo');
            let eligOk = true;
            let eligMsg = '';
            if (!selectedTerritory) {
              eligOk = false;
              eligMsg = 'Set the customer location to validate area and available days.';
            } else {
              const abd = selectedTerritory.allowedBookingDays || {};
              const wk = getWeekKeyForDate(selectedBooking.dateISO);
              const dk = getDayKeyForDate(selectedBooking.dateISO);
              const cleaners = abd[wk] && Array.isArray(abd[wk][dk]) ? abd[wk][dk] : [];
              if (!cleaners.length) {
                eligOk = false;
                const niceDay = new Date(selectedBooking.dateISO).toLocaleDateString('en-GB', { weekday: 'long' });
                const terrName = selectedTerritory.name || selectedTerritory.id || 'your area';
                eligMsg = `${niceDay} (Week ${wk.replace('week','')}) isn‚Äôt scheduled for ${terrName}.`;
              } else {
                // Optionally attach territoryId and cleanerId if not provided
                selectedBooking.territoryId = selectedBooking.territoryId || selectedTerritory.id || null;
                if (!selectedBooking.cleanerId) {
                  selectedBooking.cleanerId = cleaners[0] || null;
                }
              }
            }
            if (isSameDay) {
              eligOk = false;
              eligMsg = 'Same-day booking not allowed ‚Äì pick a future date.';
            }
            if (eligEl) eligEl.textContent = eligMsg;

            confirmBtn.disabled = over || !eligOk;
            if (over) {
              confirmBtn.textContent = 'Day over capacity (choose another)';
            } else if (!eligOk) {
              confirmBtn.textContent = 'Date not eligible for this area';
            } else {
              updateConfirmBtnState(confirmBtn);
            }
          } catch(_) {}
        })();
      }

      // Generate a small set of suggested eligible dates (next 120 days) matching territory week/day & capacity < ¬£400, skipping today
      async function generateSuggestedDates(maxCount = 5) {
        try {
          const container = document.getElementById('suggestedDatesContainer');
          if (!container) return;
          // Clear old buttons (leave heading/note)
          Array.from(container.querySelectorAll('button.suggested-date-btn')).forEach(b => b.remove());
          const pricePerCleanText = getTextPricePerClean();
          const priceNum = parseFloat(pricePerCleanText.replace(/[^0-9.]/g,'')) || 0;
          if (!selectedTerritory) selectedTerritory = await detectCustomerTerritory();
          if (!selectedTerritory) {
            const msg = document.createElement('div');
            msg.style.flexBasis='100%'; msg.style.fontSize='0.75rem'; msg.style.color='#dc2626';
            msg.textContent='Set customer location to see suggestions.';
            container.appendChild(msg);
            return;
          }
          const abd = selectedTerritory.allowedBookingDays || {};
          const today = new Date(); today.setHours(0,0,0,0);
          let cursor = new Date(today); cursor.setDate(cursor.getDate() + 1); // start tomorrow
          let found = 0;
          const limitDate = new Date(today); limitDate.setDate(limitDate.getDate() + 120);
          while (found < maxCount && cursor <= limitDate) {
            const iso = cursor.toISOString();
            const wk = getWeekKeyForDate(iso);
            const dk = getDayKeyForDate(iso);
            const cleaners = abd[wk] && Array.isArray(abd[wk][dk]) ? abd[wk][dk] : [];
            if (cleaners.length) {
              const baseTotal = await computeDayTotalGBP(iso);
              const withThis = baseTotal + priceNum;
              if (withThis <= 400) {
                // Accept
                const btn = document.createElement('button');
                btn.type='button';
                btn.className='btn btn-secondary suggested-date-btn';
                btn.style.flex='0 0 auto';
                btn.style.fontSize='0.75rem';
                const nice = cursor.toLocaleDateString('en-GB', { weekday:'short', day:'numeric', month:'short' });
                btn.textContent = nice;
                btn.title = `Week ${wk.replace('week','')} ‚Ä¢ ${dk} ‚Ä¢ Capacity after: ¬£${withThis.toFixed(2)}`;
                btn.addEventListener('click', () => {
                  window.setSelectedBooking({ dateISO: iso, weekKey: wk, dayKey: dk, territoryId: selectedTerritory.id || null, cleanerId: cleaners[0] || null });
                });
                container.appendChild(btn);
                found++;
              }
            }
            cursor.setDate(cursor.getDate() + 1);
          }
          if (found === 0) {
            const none = document.createElement('div');
            none.style.flexBasis='100%';
            none.style.fontSize='0.72rem';
            none.style.color='#64748b';
            none.textContent='No eligible days under capacity in the next 120 days.';
            container.appendChild(none);
          }
        } catch(e) {
          console.warn('generateSuggestedDates error', e);
        }
      }

      // ===== Offline UI helpers =====
      function showOfflineAcceptedUi() {
        try {
          // Banner
          const resultPanel = document.getElementById('result');
          if (resultPanel && !document.getElementById('offlineBanner')) {
            const b = document.createElement('div');
            b.id = 'offlineBanner';
            b.style.background = '#fff7ed';
            b.style.border = '1px solid #fcd34d';
            b.style.color = '#92400e';
            b.style.padding = '8px 10px';
            b.style.borderRadius = '8px';
            b.style.marginTop = '8px';
            b.textContent = 'üì° Offline Submission Detected ‚Äî a payment link will be emailed when internet is restored.';
            resultPanel.appendChild(b);
          }
          // Next to Quote Accepted button
          const actionRow = document.getElementById('quoteAcceptedRow');
          if (actionRow && !document.getElementById('offlineBadgeQa')) {
            const s = document.createElement('span');
            s.id = 'offlineBadgeQa';
            s.style.marginLeft = '8px';
            s.style.color = '#92400e';
            s.style.fontWeight = '600';
            s.textContent = 'üì° Offline ‚Äî Payment link will be sent when back online';
            actionRow.appendChild(s);
          }
          // Change Confirm Booking button label
          const cb = document.getElementById('confirmBookingBtn');
          if (cb) {
            cb.textContent = 'Submit Offline';
            cb.disabled = false;
          }
          const fallbackBtn = document.getElementById('submitBtn');
          if (fallbackBtn) fallbackBtn.hidden = false;
        } catch(_) {}
      }

      // ===== Offline Sync (Online event) =====
      async function syncOfflineQueue() {
        try {
          const now = Date.now();
          const items = (await idbGetAll()).filter(x => x.offlineSubmitted && !x.offlineEmailSent && (!x.retryAt || x.retryAt <= now));
          if (!items.length) return;
          for (const it of items) {
            try {
              // Create payment link
              const desc = `Payment from ${it.customerName || 'Customer'} for 3 window cleans - Rep ${localStorage.getItem('swash:lastRepName') || ''}`;
              const resp = await fetch('/api/createInstantPayLink', {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ amount: Math.round((Number(it.totalAmount)||0)*100), currency: 'GBP', description: desc })
              });
              if (!resp.ok) throw new Error('Link create failed');
              const { redirect_url, session_id, billing_request } = await resp.json();
              const paymentLink = redirect_url;
              const gRef = (billing_request && billing_request.id) || null;
              await idbUpdate(it.id, { paymentLink, gocardlessRef: gRef });

              // Send offline payment email via EmailJS (universal blank template fields only)
              if (window.emailjs && emailjs.send) {
                const totalStr = Number(it.totalAmount||0).toFixed(2);
                const body = `Please use this secure payment link to complete your upfront payment of ¬£${totalStr} for your ${it.propertyType} on the ${it.tierLabel} plan:\n\n${paymentLink}\n\nOnce payment is completed, we will email you with all available booking dates for your first clean.\nIf you have any questions, just reply to this email. Thank you!`;
                await emailjs.send(
                  'service_cdy739m',
                  'template_6mpufs4',
                  {
                    title: 'Payment Link ‚Äì Swash Cleaning Ltd',
                    name: it.customerName,
                    message: body
                  }
                );
              }

              // Create Firestore record under customers/{customerId}/quotes
              const db = window.db; if (db) {
                const mod = await import('https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js');
                const { collection, addDoc } = mod;
                const customerId = await ensureCustomerDocFromEntry(it);
                if (customerId) {
                  await addDoc(collection(db, 'customers', customerId, 'quotes'), {
                    offlineSubmitted: true,
                    offlineEmailSent: true,
                    paymentLink,
                    gocardlessRef: gRef,
                    totalAmount: Number(it.totalAmount||0),
                    tierLabel: it.tierLabel || '',
                    propertyType: it.propertyType || '',
                    status: 'pending_payment',
                    timestamp: new Date().toISOString(),
                    territoryId: it.territoryId || null,
                    repId: it.repId || null,
                    retryCount: it.retryCount || 0
                  });
                }
              }

              await idbUpdate(it.id, { offlineEmailSent: true });
              window.offlineEmailSentFlag = true;
            } catch (e) {
              const next = Date.now() + 5*60*1000; // retry in 5 mins
              const rc = (it.retryCount || 0) + 1;
              await idbUpdate(it.id, { retryAt: next, retryCount: rc });
            }
          }
          showToast('‚úÖ Offline quotes synced and emails sent', 'success');
        } catch(e) {
          console.warn('syncOfflineQueue failed', e);
        }
      }

      async function startOfflineWatcher() {
        window.addEventListener('online', () => syncOfflineQueue());
        // If currently offline and a queue item exists, show banner
        try {
          const items = await idbGetAll();
          if (!navigator.onLine && items.some(x => x.offlineSubmitted && !x.offlineEmailSent)) {
            showOfflineAcceptedUi();
          }
        } catch(_) {}
      }

      // Ensure these helpers are globally available
      window.syncOfflineQueue = syncOfflineQueue;
      window.startOfflineWatcher = startOfflineWatcher;
      window.sendOfflinePaymentEmail = async function(entry){
        // A thin wrapper that attempts to send the offline email for a single entry id
        const items = await idbGetAll();
        const it = items.find(x => x.id === entry?.id);
        if (it) {
          await idbUpdate(it.id, { offlineEmailSent: false });
          await syncOfflineQueue();
        }
      };
      async function ensureCustomerDocFromEntry(entry) {
        try {
          const db = window.db; if (!db || !entry) return null;
          const mod = await import('https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js');
          const { collection, addDoc, query, where, getDocs } = mod;
          if (entry.customerEmail) {
            try {
              const q = query(collection(db, 'customers'), where('email','==', entry.customerEmail));
              const snap = await getDocs(q);
              for (const d of snap.docs) return d.id;
            } catch(_) {}
          }
          const docRef = await addDoc(collection(db, 'customers'), {
            name: entry.customerName || 'Customer',
            email: entry.customerEmail || '',
            address: entry.address || '',
            territoryId: entry.territoryId || null,
            repId: entry.repId || null,
            createdAt: new Date().toISOString(),
            source: 'offline-queue'
          });
          return docRef.id;
        } catch(e) { console.warn('ensureCustomerDocFromEntry failed', e); return null; }
      }
      window.ensureCustomerDocFromEntry = ensureCustomerDocFromEntry;
      // Detect existing offline submission / paid status when loading or after email entry
      async function checkOfflineState() {
        try {
          const emailInput = document.getElementById('customerEmail');
          const emailVal = emailInput && emailInput.value && emailInput.value.trim();
          if (!emailVal) return; // wait until email provided
          const db = window.db; if (!db) return;
          const mod = await import('https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js');
          const { collectionGroup, query, where, getDocs } = mod;
          const qRef = query(collectionGroup(db,'quotes'), where('email','==', emailVal), where('offlineSubmitted','==', true));
          const snap = await getDocs(qRef);
          if (snap.empty) return;
          const docData = snap.docs[0].data();
          // Hide online flow elements
          try { document.getElementById('quoteAcceptedBtn')?.setAttribute('hidden',''); } catch(_) {}
          try { document.getElementById('instantPayModal')?.setAttribute('hidden',''); } catch(_) {}
          window.offlineSubmissionActive = true;
          // Banner logic
          const resultPanel = document.getElementById('result');
          if (resultPanel) {
            const existing = document.getElementById('offlineBanner');
            if (!existing) {
              const b = document.createElement('div');
              b.id='offlineBanner';
              b.style.background = '#fff7ed';
              b.style.border='1px solid #fcd34d';
              b.style.color='#92400e';
              b.style.padding='8px 10px';
              b.style.borderRadius='8px';
              b.style.marginTop='8px';
              if (docData.status === 'paid') {
                window.paymentReceivedFlag = true;
                b.textContent = 'üí∏ Payment Received ‚Äî you can now select a booking slot.';
              } else {
                b.textContent = 'üì° Offline Submission Detected ‚Äî payment link sent, awaiting payment.';
              }
              resultPanel.appendChild(b);
            }
          }
        } catch(e) { /* silent */ }
      }
      window.checkOfflineState = checkOfflineState;
      document.getElementById('customerEmail')?.addEventListener('blur', () => { checkOfflineState(); });
      // Initial check shortly after load (in case email prefilled)
      setTimeout(() => { try { checkOfflineState(); } catch(_) {} }, 1200);

      // --- Quote update helpers (ensure scheduler + admin reflect booking) ---
      async function findQuoteDocIdByRefCode(refCode) {
        if (!refCode) return null;
        try {
          const db = window.db; if (!db) return null;
          const { collection, query, where, getDocs } = await import('https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js');
          const q = query(collection(db, 'quotes'), where('refCode', '==', refCode));
          const snap = await getDocs(q);
          for (const docSnap of snap.docs) {
            return docSnap.id;
          }
          return null;
        } catch (e) { console.warn('findQuoteDocIdByRefCode failed', e); return null; }
      }

      function broadcastQuotesUpdated(source) {
        try {
          const chan = new BroadcastChannel('swash-quotes-sync');
          chan.postMessage({ type: 'quotes-updated', source: source || 'add-new-customer' });
          chan.close();
        } catch(_) {}
        // Notify embedding parent window (rep log modal) for quick logging
        try {
          const isEmbedded = (function(){ try { return window.self !== window.top; } catch(_) { return true; } })();
          if (isEmbedded && window.parent) {
            let refCode = null;
            try { refCode = document.getElementById('paymentRefValue')?.textContent?.trim() || null; } catch(_) {}
            let form = {};
            try { if (typeof getCustomerFormData === 'function') form = getCustomerFormData() || {}; } catch(_) {}
            const payload = {
              type: 'swash-signup-saved',
              source: source || 'add-new-customer',
              ref_code: refCode,
              customer_name: form.name || '',
              address: form.address || '',
              email: form.email || '',
            };
            window.parent.postMessage(payload, location.origin);
          }
        } catch(_) {}
      }

      async function updateQuoteDocAfterBooking(refCode, { first, second, third, cleanerId }) {
        let quoteId = await findQuoteDocIdByRefCode(refCode);
        if (!quoteId) {
          // Create a minimal quote so admin/scheduler reflect status
          quoteId = await createOrLinkQuoteFromForm(refCode, { status: 'Booked - ' + new Date(first).toLocaleDateString('en-GB') });
          if (!quoteId) return;
        }
        try {
          const db = window.db; if (!db) return;
          const { doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js');
          const ddmmyyyy = (d) => {
            const date = new Date(d); return `${String(date.getDate()).padStart(2,'0')}/${String(date.getMonth()+1).padStart(2,'0')}/${date.getFullYear()}`;
          };
          await updateDoc(doc(db, 'quotes', quoteId), {
            status: 'Booked - ' + ddmmyyyy(first),
            bookedDate: first.toISOString(),
            nextCleanDates: [ second.toISOString(), third.toISOString() ],
            assignedCleaner: cleanerId || null
          });
          broadcastQuotesUpdated('add-new-customer');
        } catch (e) { console.warn('updateQuoteDocAfterBooking failed', e); }
      }

      async function updateQuoteDocPending(refCode) {
        let quoteId = await findQuoteDocIdByRefCode(refCode);
        if (!quoteId) {
          // Create a minimal quote with pending status
          const paidStr = formatDdMmYyyyToday();
          quoteId = await createOrLinkQuoteFromForm(refCode, { status: `Paid - ${paidStr} - Scheduling Soon` });
          if (!quoteId) return;
        }
        try {
          const db = window.db; if (!db) return;
          const { doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js');
          const paidStr = formatDdMmYyyyToday();
          await updateDoc(doc(db, 'quotes', quoteId), {
            status: `Paid - ${paidStr} - Scheduling Soon`
          });
          broadcastQuotesUpdated('add-new-customer');
        } catch (e) { console.warn('updateQuoteDocPending failed', e); }
      }

      // Create or merge a minimal quote in Firestore so admin/scheduler always see status
      async function createOrLinkQuoteFromForm(refCode, overrides = {}) {
        try {
          const db = window.db; if (!db) return null;
          const existingId = await findQuoteDocIdByRefCode(refCode);
          const mod = await import('https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js');
          const { collection, addDoc, doc, setDoc, serverTimestamp } = mod;
          const form = getCustomerFormData();
          const repInput = document.getElementById('repCode');
          const repCode = (repInput && repInput.value) ? String(repInput.value).trim() : (getRepName && getRepName()) || 'Website Quote';
          const pricePerClean = parseGBP(form.pricePerCleanText);
          const upfront = parseGBP(getTextUpfront()) || Number((pricePerClean * 3).toFixed(2));
          const payload = {
            repCode: (repCode || 'Website Quote').toUpperCase(),
            customerName: form.name || 'Customer',
            address: form.address || '',
            mobile: form.mobile || '',
            email: form.email || '',
            tier: form.tier || 'silver',
            houseType: form.houseType || '',
            houseSize: form.houseSize || '',
            pricePerClean: pricePerClean || 0,
            price: upfront || 0,
            refCode: refCode,
            status: overrides.status || 'Paid - Scheduling Soon',
            bookedDate: null,
            nextCleanDates: [],
            assignedCleaner: null,
            date: serverTimestamp(),
            deleted: false,
          };
          if (existingId) {
            // Merge updates onto existing quote
            await setDoc(doc(db, 'quotes', existingId), payload, { merge: true });
            return existingId;
          }
          const created = await addDoc(collection(db, 'quotes'), payload);
          return created?.id || null;
        } catch (e) {
          console.warn('createOrLinkQuoteFromForm failed', e);
          return null;
        }
      }

      // Thank-you overlay on successful booking
      function showThankYouOverlay(customerName, dateNice) {
        try {
          let ov = document.getElementById('thanksOverlay');
          if (!ov) return;
          const name = customerName || 'Customer';
          const when = dateNice || '';
          const msg = ov.querySelector('.thanks__message');
          if (msg) msg.innerHTML = `Thank you, <strong>${name}</strong>.<br>Your windows will be cleaned on <strong>${when}</strong>.<br>See you soon!`;
          ov.hidden = false;
          ov.style.display = 'flex';
        } catch(_) {}
      }
    })();
  </script>

  <!-- Thank-you Overlay -->
  <div id="thanksOverlay" hidden style="position: fixed; inset: 0; display:none; align-items:center; justify-content:center; z-index: 1200; background:#004a99;">
    <div style="position:relative; background:#0078d7; border-radius:20px; padding:32px; width:min(92vw,520px); box-shadow:0 25px 45px rgba(0,0,0,0.35); text-align:center; color:#fff;">
      <img src="../assets/swash-logo.png" alt="Swash" style="height:48px; margin-bottom: 12px; filter:drop-shadow(0 4px 8px rgba(0,0,0,0.25));" />
      <div class="thanks__message" style="font-size:1.2rem; line-height:1.7; color:#fff;"></div>
      <div style="margin-top:20px;">
        <button type="button" class="btn btn-secondary" style="background:#fff; color:#0078d7; border:none;" onclick="document.getElementById('thanksOverlay').style.display='none'; document.getElementById('thanksOverlay').hidden=true;">Close</button>
      </div>
    </div>
  </div>
  <script>
    // Post height to parent for dynamic iframe resizing
    (function(){
      function computeContentHeight(){
        try {
          const card = document.querySelector('main.page .card') || document.getElementById('quoteForm') || document.body;
          const rect = card.getBoundingClientRect();
          // Add a small buffer for margins/padding
          const h = Math.ceil(rect.height + 24);
          // Sanity clamp to avoid accidental huge values
          return Math.max(300, Math.min(h, 2000));
        } catch (_) {
          return Math.max(300, Math.min(document.body.scrollHeight || 600, 2000));
        }
      }
      function postHeight() {
        try {
          const h = computeContentHeight();
          parent.postMessage({ type: 'SWASH_IFRAME_HEIGHT', height: h }, '*');
        } catch (_) {}
      }
      if (window.self !== window.top) {
        const ro = new ResizeObserver(() => postHeight());
        ro.observe(document.documentElement);
        window.addEventListener('load', postHeight);
        setTimeout(postHeight, 400);
        setTimeout(postHeight, 1200);
        // Avoid long periodic growth ‚Äì recalc only on orientation/resize
        window.addEventListener('orientationchange', () => setTimeout(postHeight, 300));
        window.addEventListener('resize', () => setTimeout(postHeight, 200));
      }
    })();
  </script>
  <script>
    // Start offline watcher on load
    (function(){
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => { try { window.startOfflineWatcher && window.startOfflineWatcher(); } catch(_) {} }, { once: true });
      } else {
        try { window.startOfflineWatcher && window.startOfflineWatcher(); } catch(_) {}
      }
    })();
  </script>
</body>
</html>
